<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />


<meta name="description" content="这是水滴产品团队面向 Scala 的中文技术博客，原创 Scala 文章、教程。"/>


<meta name="keywords" content="scala,scala 教程,scala 文章,scala 中文,scala 社区" />

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>



  <link rel="alternate" href="/default" title="Scala Cool">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://scala.cool/2017/07/learning-akka-7/"/>


<meta name="description" content="这次把这部分内容提到现在写，是因为这段时间开发的项目刚好在这一块遇到了一些难点，所以准备把经验分享给大家，我们在使用Akka时，会经常遇到一些存储Actor内部状态的场景…">
<meta name="keywords" content="Akka">
<meta property="og:type" content="article">
<meta property="og:title" content="Akka 系列（七）：Actor 持久化之 Akka persistence">
<meta property="og:url" content="http://scala.cool/2017/07/learning-akka-7/index.html">
<meta property="og:site_name" content="Scala Cool">
<meta property="og:description" content="这次把这部分内容提到现在写，是因为这段时间开发的项目刚好在这一块遇到了一些难点，所以准备把经验分享给大家，我们在使用Akka时，会经常遇到一些存储Actor内部状态的场景…">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://scala.cool/images/2017/07/result-persistence-demo.png">
<meta property="og:updated_time" content="2017-07-25T05:13:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Akka 系列（七）：Actor 持久化之 Akka persistence">
<meta name="twitter:description" content="这次把这部分内容提到现在写，是因为这段时间开发的项目刚好在这一块遇到了一些难点，所以准备把经验分享给大家，我们在使用Akka时，会经常遇到一些存储Actor内部状态的场景…">
<meta name="twitter:image" content="http://scala.cool/images/2017/07/result-persistence-demo.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dfcb338d3c2ed49b6a5e26760868e19f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> Akka 系列（七）：Actor 持久化之 Akka persistence - Scala Cool </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead" ><div class="site-header-inner">
      
    <h1 class="site-title">
        <a href="/." class="logo">Scala Cool</a>
    </h1>
      
    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="http://news.scala.cool">
                            
                            
                                News
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Akka 系列（七）：Actor 持久化之 Akka persistence
        
      </h1>

      <time class="post-time">
          7月25日
      </time>
      
        <span class="author-split">|</span>
        <span class="author-info">
          by <span class="_author-text-holder" data-author="Godpan"></span>
        </span>
      
      
        <span class="_author-avatar-holder" data-author="Godpan"></span>
      
    </header>



    
            <div class="post-content">
            <p>这次把这部分内容提到现在写，是因为这段时间开发的项目刚好在这一块遇到了一些难点，所以准备把经验分享给大家，我们在使用Akka时，会经常遇到一些存储Actor内部状态的场景，在系统正常运行的情况下，我们不需要担心什么，但是当系统出错，比如Actor错误需要重启，或者内存溢出，亦或者整个系统崩溃，如果我们不采取一定的方案的话，在系统重启时Actor的状态就会丢失，这会导致我们丢失一些关键的数据，造成系统数据不一致的问题。Akka作为一款成熟的生产环境应用，为我们提供了相应的解决方案就是Akka persistence。</p>
<h3 id="为什么需要持久化的Actor？"><a href="#为什么需要持久化的Actor？" class="headerlink" title="为什么需要持久化的Actor？"></a>为什么需要持久化的Actor？</h3><p>万变不离其宗，数据的一致性是永恒的主题，一个性能再好的系统，不能保证数据的正确，也称不上是一个好的系统，一个系统在运行的时候难免会出错，如何保证系统在出错后能正确的恢复数据，不让数据出现混乱是一个难题。使用Actor模型的时候，我们会有这么一个想法，就是能不对数据库操作就尽量不对数据库操作（这里我们假定我们的数据库是安全，可靠的，能保证数据的正确性和一致性，比如使用国内某云的云数据库），一方面如果大量的数据操作会使数据库面临的巨大的压力，导致崩溃，另一方面即使数据库能处理的过来，比如一些count，update的大表操作也会消耗很多的时间，远没有内存中直接操作来的快，大大影响性能。但是又有人说内存操作这么快，为什么不把数据都放内存中呢？答案显而易见，当出现机器死机，或者内存溢出等问题时，数据很有可能就丢失了导致无法恢复。在这种背景下，我们是不是有一种比较好的解决方案，既能满足需求又能用最小的性能消耗，答案就是上面我们的说的Akka persistence。</p>
<h3 id="Akka-persistence的核心架构"><a href="#Akka-persistence的核心架构" class="headerlink" title="Akka persistence的核心架构"></a>Akka persistence的核心架构</h3><p>在具体深入Akka persistence之前，我们可以先了解一下它的核心设计理念，其实简单来说，我们可以利用一些thing来恢复Actor的状态，这里的thing可以是日志、数据库中的数据，亦或者是文件，所以说它的本质非常容易理解，在Actor处理的时候我们会保存一些数据，Actor在恢复的时候能根据这些数据恢复其自身的状态。</p>
<p>所以Akka persistence 有以下几个关键部分组成：</p>
<ul>
<li>PersistentActor：任何一个需要持久化的Actor都必须继承它，并必须定义或者实现其中的三个关键属性：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">persistenceId</span> </span>= <span class="string">"example"</span> <span class="comment">//作为持久化Actor的唯一表示，用于持久化或者查询时使用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveCommand</span></span>: <span class="type">Receive</span> = ??? <span class="comment">//Actor正常运行时处理处理消息逻辑，可在这部分内容里持久化自己想要的消息</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveRecover</span></span>: <span class="type">Receive</span> = ??? <span class="comment">//Actor重启恢复是执行的逻辑</span></div></pre></td></tr></table></figure>
<p>相比普通的Actor，除receiveCommand相似以外，还必须实现另外两个属性。<br>另外在持久化Actor中还有另外两个关键的的概念就是<em>Journal</em>和<em>Snapshot</em>，前者用于持久化事件，后者用于保存Actor的快照，两者在Actor恢复状态的时候都起到了至关重要的作用。</p>
<h3 id="Akka-persistence的demo实战"><a href="#Akka-persistence的demo实战" class="headerlink" title="Akka persistence的demo实战"></a>Akka persistence的demo实战</h3><p>这里我首先会用一个demo让大家能对Akka persistence的使用有一定了解的，并能大致明白它的工作原理，后面再继续讲解一些实战可能会遇到的问题。</p>
<p>假定现在有这么一个场景，现在假设有一个1w元的大红包，瞬间可能会很多人同时来抢，每个人抢的金额也可能不一样，场景很简单，实现方式也有很多种，但前提是保证数据的正确性，比如最普通的使用数据库保证，但对这方面有所了解的同学都知道这并不是一个很好的方案，因为需要锁，并需要大量的数据库操作，导致性能不高，那么我们是否可以用Actor来实现这个需求么？答案是当然可以。</p>
<p>我们首先来定义一个抽奖命令，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LotteryCmd</span>(<span class="params"></span></span></div><div class="line">  userId: <span class="type">Long</span>, // 参与用户<span class="type">Id</span></div><div class="line">  username: <span class="type">String</span>, //参与用户名</div><div class="line">  email: <span class="type">String</span> // 参与用户邮箱</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>然后我们实现一个抽奖Actor，并继承PersistentActor作出相应的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LuckyEvent</span>(<span class="params">  //抽奖成功事件</span></span></div><div class="line">    userId: <span class="type">Long</span>,</div><div class="line">    luckyMoney: <span class="type">Int</span></div><div class="line">)</div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FailureEvent</span>(<span class="params">  //抽奖失败事件</span></span></div><div class="line">    userId: <span class="type">Long</span>,</div><div class="line">    reason: <span class="type">String</span></div><div class="line">)</div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Lottery</span>(<span class="params"></span></span></div><div class="line">    totalAmount: <span class="type">Int</span>,  //红包总金额</div><div class="line">    remainAmount: <span class="type">Int</span>  //剩余红包金额</div><div class="line">) &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(luckyMoney: <span class="type">Int</span>) = &#123;</div><div class="line">    copy(</div><div class="line">      remainAmount = remainAmount - luckyMoney</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryActor</span>(<span class="params">initState: <span class="type">Lottery</span></span>) <span class="keyword">extends</span> <span class="title">PersistentActor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span></span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">persistenceId</span></span>: <span class="type">String</span> = <span class="string">"lottery-actor-1"</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> state = initState  <span class="comment">//初始化Actor的状态</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveRecover</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> event: <span class="type">LuckyEvent</span> =&gt;</div><div class="line">      updateState(event)  <span class="comment">//恢复Actor时根据持久化的事件恢复Actor状态</span></div><div class="line">    <span class="keyword">case</span> <span class="type">SnapshotOffer</span>(_, snapshot: <span class="type">Lottery</span>) =&gt;</div><div class="line">      log.info(<span class="string">s"Recover actor state from snapshot and the snapshot is <span class="subst">$&#123;snapshot&#125;</span>"</span>)</div><div class="line">      state = snapshot <span class="comment">//利用快照恢复Actor的状态</span></div><div class="line">    <span class="keyword">case</span> <span class="type">RecoveryCompleted</span> =&gt; log.info(<span class="string">"the actor recover completed"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">updateState</span></span>(le: <span class="type">LuckyEvent</span>) =</div><div class="line">    state = state.update(le.luckyMoney)  <span class="comment">//更新自身状态</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveCommand</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> lc: <span class="type">LotteryCmd</span> =&gt;</div><div class="line">      doLottery(lc) <span class="keyword">match</span> &#123;     <span class="comment">//进行抽奖，并得到抽奖结果，根据结果做出不同的处理</span></div><div class="line">        <span class="keyword">case</span> le: <span class="type">LuckyEvent</span> =&gt;  <span class="comment">//抽到随机红包</span></div><div class="line">          persist(le) &#123; event =&gt;</div><div class="line">            updateState(event)</div><div class="line">            increaseEvtCountAndSnapshot()</div><div class="line">            sender() ! event</div><div class="line">          &#125;</div><div class="line">        <span class="keyword">case</span> fe: <span class="type">FailureEvent</span> =&gt;  <span class="comment">//红包已经抽完</span></div><div class="line">          sender() ! fe</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">case</span> <span class="string">"saveSnapshot"</span> =&gt;  <span class="comment">// 接收存储快照命令执行存储快照操作</span></div><div class="line">      saveSnapshot(state)</div><div class="line">    <span class="keyword">case</span> <span class="type">SaveSnapshotSuccess</span>(metadata) =&gt;  ???  <span class="comment">//你可以在快照存储成功后做一些操作，比如删除之前的快照等</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">increaseEvtCountAndSnapshot</span></span>() = &#123;</div><div class="line">    <span class="keyword">val</span> snapShotInterval = <span class="number">5</span></div><div class="line">    <span class="keyword">if</span> (lastSequenceNr % snapShotInterval == <span class="number">0</span> &amp;&amp; lastSequenceNr != <span class="number">0</span>) &#123;  <span class="comment">//当有持久化5个事件后我们便存储一次当前Actor状态的快照</span></div><div class="line">      self ! <span class="string">"saveSnapshot"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">doLottery</span></span>(lc: <span class="type">LotteryCmd</span>) = &#123;  <span class="comment">//抽奖逻辑具体实现</span></div><div class="line">    <span class="keyword">if</span> (state.remainAmount &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">val</span> luckyMoney = scala.util.<span class="type">Random</span>.nextInt(state.remainAmount) + <span class="number">1</span></div><div class="line">      <span class="type">LuckyEvent</span>(lc.userId, luckyMoney)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="type">FailureEvent</span>(lc.userId, <span class="string">"下次早点来，红包已被抽完咯！"</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序很简单，关键位置我也给了注释，相信大家对Actor有所了解的话很容易理解，当然要是有些疑惑，可以看看我之前写的文章，下面我们就对刚才写的抽红包Actor进行测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">PersistenceTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line">  <span class="keyword">val</span> lottery = <span class="type">Lottery</span>(<span class="number">10000</span>,<span class="number">10000</span>)</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"example-05"</span>)</div><div class="line">  <span class="keyword">val</span> lotteryActor = system.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">LotteryActor</span>(lottery)), <span class="string">"LotteryActor-1"</span>)  <span class="comment">//创建抽奖Actor</span></div><div class="line">  <span class="keyword">val</span> pool: <span class="type">ExecutorService</span> = <span class="type">Executors</span>.newFixedThreadPool(<span class="number">10</span>)</div><div class="line">  <span class="keyword">val</span> r = (<span class="number">1</span> to <span class="number">100</span>).map(i =&gt;</div><div class="line">    <span class="keyword">new</span> <span class="type">LotteryRun</span>(lotteryActor, <span class="type">LotteryCmd</span>(i.toLong,<span class="string">"godpan"</span>,<span class="string">"xx@gmail.com"</span>))  <span class="comment">//创建100个抽奖请求</span></div><div class="line">  )</div><div class="line">  r.map(pool.execute(_))  <span class="comment">//使用线程池来发起抽奖请求，模拟同时多人参加</span></div><div class="line">  <span class="type">Thread</span>.sleep(<span class="number">5000</span>)</div><div class="line">  pool.shutdown()</div><div class="line">  system.terminate()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryRun</span>(<span class="params">lotteryActor: <span class="type">ActorRef</span>, lotteryCmd: <span class="type">LotteryCmd</span></span>) <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">//抽奖请求</span></div><div class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">3.</span>seconds)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>: <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">      fut &lt;- lotteryActor ? lotteryCmd</div><div class="line">    &#125; <span class="keyword">yield</span> fut <span class="keyword">match</span> &#123;  <span class="comment">//根据不同事件显示不同的抽奖结果</span></div><div class="line">      <span class="keyword">case</span> le: <span class="type">LuckyEvent</span> =&gt; println(<span class="string">s"恭喜用户<span class="subst">$&#123;le.userId&#125;</span>抽到了<span class="subst">$&#123;le.luckyMoney&#125;</span>元红包"</span>)</div><div class="line">      <span class="keyword">case</span> fe: <span class="type">FailureEvent</span> =&gt;  println(fe.reason)</div><div class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"系统错误，请重新抽取"</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序,我们可能看到以下的结果：</p>
<center><br><img src="/images/2017/07/result-persistence-demo.png" alt="result persistence demo"><br></center>

<p>下面我会把persistence actor在整个运行过程的步骤给出，帮助大家理解它的原理：</p>
<ul>
<li><p>1.初始化Persistence Actor</p>
<ul>
<li>1.1若是第一次初始化，则与正常的Actor的初始化一致。</li>
<li>1.2若是重启恢复Actor，这根据Actor之前持久的数据恢复。<ul>
<li>1.2.1从快照恢复，可快速恢复Actor，但并非每次持久化事件都会保存快照，在快照完整的情况下，Actor优先从快照恢复自身状态。</li>
<li>1.2.2从事件（日志，数据库记录等）恢复，通过重放持久化事件恢复Actor状态，比较关键。</li>
</ul>
</li>
</ul>
</li>
<li><p>2.接收命令进行处理，转化为需要持久化的事件（持久化的事件尽量只包含关键性的数据）使用Persistence Actor的持久化方法进行持久化（上述例子中的persist，后面我会讲一下批量持久化），并处理持久化成功后的逻辑处理，比如修改Actor状态，向外部Actor发送消息等。</p>
</li>
<li><p>3.若是我们需要存储快照，那么可以主动指定存储快照的频率，比如持久化事件100次我们就存储一次快照，这个频率应该要考虑实际的业务场景，在存储快照成功后我们也可以执行一些操作。</p>
</li>
</ul>
<p>总的来说Persistence Actor运行时的大致操作就是以上这些，当然它是r如何持久化事件，恢复时的机制是怎么样的等有兴趣的可以看一下Akka源码。</p>
<h3 id="使用Akka-persistence的相关配置"><a href="#使用Akka-persistence的相关配置" class="headerlink" title="使用Akka persistence的相关配置"></a>使用Akka persistence的相关配置</h3><p>首先我们必须加载相应的依赖包，在<code>bulid.sbt</code>中加入以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">libraryDependencies ++= Seq(</div><div class="line">&quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.4.16&quot;,  //Akka actor 核心依赖</div><div class="line">  &quot;com.typesafe.akka&quot; %% &quot;akka-persistence&quot; % &quot;2.4.16&quot;, //Akka persistence 依赖</div><div class="line">  &quot;org.iq80.leveldb&quot;            % &quot;leveldb&quot;          % &quot;0.7&quot;, //leveldb java版本依赖</div><div class="line">  &quot;org.fusesource.leveldbjni&quot;   % &quot;leveldbjni-all&quot;   % &quot;1.8&quot;, //leveldb java版本依赖</div><div class="line">  &quot;com.twitter&quot;              %% &quot;chill-akka&quot;                  % &quot;0.8.0&quot; //事件序列化依赖</div><div class="line">)</div></pre></td></tr></table></figure>
<p>另外我们还需在<code>application.conf</code>加入以下配置:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">akka.persistence.journal.plugin = <span class="string">"akka.persistence.journal.leveldb"</span></div><div class="line">akka.persistence.snapshot-store.plugin = <span class="string">"akka.persistence.snapshot-store.local"</span></div><div class="line"></div><div class="line">akka.persistence.journal.leveldb.dir = <span class="string">"log/journal"</span></div><div class="line">akka.persistence.snapshot-store.local.dir = <span class="string">"log/snapshots"</span></div><div class="line"></div><div class="line"># <span class="type">DO</span> <span class="type">NOT</span> <span class="type">USE</span> <span class="type">THIS</span> <span class="type">IN</span> <span class="type">PRODUCTION</span> !!!</div><div class="line"># <span class="type">See</span> also https:<span class="comment">//github.com/typesafehub/activator/issues/287</span></div><div class="line">akka.persistence.journal.leveldb.native = <span class="literal">false</span>  <span class="comment">//因为我们本地并没有安装leveldb，所以这个属性置为false，但是生产环境并不推荐使用</span></div><div class="line"></div><div class="line">akka.actor.serializers &#123;</div><div class="line">  kryo = <span class="string">"com.twitter.chill.akka.AkkaSerializer"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">akka.actor.serialization-bindings &#123;</div><div class="line">  <span class="string">"scala.Product"</span> = kryo</div><div class="line">  <span class="string">"akka.persistence.PersistentRepr"</span> = kryo</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此为止我们整个Akka persistence demo已经搭建好了，可以正常运行了，有兴趣的同学可以下载源码。<a href="https://github.com/godpan/akka-demo/tree/master/Example_05" target="_blank" rel="external">源码链接</a></p>
<h3 id="Akka-persistence进阶"><a href="#Akka-persistence进阶" class="headerlink" title="Akka persistence进阶"></a>Akka persistence进阶</h3><h4 id="1-持久化插件"><a href="#1-持久化插件" class="headerlink" title="1.持久化插件"></a>1.持久化插件</h4><p>有同学可能会问，我对leveldb不是很熟悉亦或者觉得单机存储并不是安全，有没有支持分布式数据存储的插件呢，比如某爸的云数据库？答案当然是有咯，良心的我当然是帮你们都找好咯。</p>
<ul>
<li><p>1.akka-persistence-sql-async: 支持MySQL和PostgreSQL，另外使用了全异步的数据库驱动，提供异步非阻塞的API，我司用的就是它的变种版，6的飞起。<a href="https://github.com/okumin/akka-persistence-sql-async" target="_blank" rel="external">项目地址</a></p>
</li>
<li><p>2.akka-persistence-cassandra: 官方推荐的插件，使用写性能very very very fast的cassandra数据库，是几个插件中比较流行的一个，另外它还支持persistence query。<a href="https://github.com/krasserm/akka-persistence-cassandra" target="_blank" rel="external">项目地址</a></p>
</li>
<li><p>3.akka-persistence-redis: redis应该也很符合Akka persistence的场景，熟悉redis的同学可以使用看看。<a href="https://github.com/hootsuite/akka-persistence-redis" target="_blank" rel="external">项目地址</a></p>
</li>
<li><p>4.akka-persistence-jdbc: 怎么能少了jdbc呢？不然怎么对的起java爸爸呢，支持scala和java哦。<a href="https://github.com/dnvriend/akka-persistence-jdbc" target="_blank" rel="external">项目地址</a></p>
</li>
</ul>
<p>相应的插件的具体使用可以看该项目的具体介绍使用，我看了下相对来说都是比较容易的。</p>
<h4 id="2-批量持久化"><a href="#2-批量持久化" class="headerlink" title="2.批量持久化"></a>2.批量持久化</h4><p>上面说到我司用的是akka-persistence-sql-async插件，所以我们是将事件和快照持久化到数据库的，一开始我也是像上面demo一样，每次事件都会持久化到数据库，但是后来在性能测试的时候，因为本身业务场景对数据库的压力也比较大，在当数据库到达每秒1000+的读写量后，另外说明一下使用的是某云数据库，性能中配以上，发现每次持久化的时间将近要15ms，这样换算一下的话Actor每秒只能处理60~70个需要持久化的事件，而实际业务场景要求Actor必须在3秒内返回处理结果，这种情况下导致大量消息处理超时得不到反馈，另外还有大量的消息得不到处理，导致系统错误暴增，用户体验下降，既然我们发现了问题，那么我们能不能进行优化呢?事实上当然是可以，既然单个插入慢，那么我们能不能批量插入呢，Akka persistence为我们提供了persistAll方法，下面我就对上面的demo进行一下改造，让其变成批量持久化：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryActorN</span>(<span class="params">initState: <span class="type">Lottery</span></span>) <span class="keyword">extends</span> <span class="title">PersistentActor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span></span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">persistenceId</span></span>: <span class="type">String</span> = <span class="string">"lottery-actor-2"</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> state = initState  <span class="comment">//初始化Actor的状态</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveRecover</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> event: <span class="type">LuckyEvent</span> =&gt;</div><div class="line">      updateState(event)  <span class="comment">//恢复Actor时根据持久化的事件恢复Actor状态</span></div><div class="line">    <span class="keyword">case</span> <span class="type">SnapshotOffer</span>(_, snapshot: <span class="type">Lottery</span>) =&gt;</div><div class="line">      log.info(<span class="string">s"Recover actor state from snapshot and the snapshot is <span class="subst">$&#123;snapshot&#125;</span>"</span>)</div><div class="line">      state = snapshot <span class="comment">//利用快照恢复Actor的状态</span></div><div class="line">    <span class="keyword">case</span> <span class="type">RecoveryCompleted</span> =&gt; log.info(<span class="string">"the actor recover completed"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">updateState</span></span>(le: <span class="type">LuckyEvent</span>) =</div><div class="line">    state = state.update(le.luckyMoney)  <span class="comment">//更新自身状态</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> lotteryQueue : <span class="type">ArrayBuffer</span>[(<span class="type">LotteryCmd</span>, <span class="type">ActorRef</span>)] = <span class="type">ArrayBuffer</span>()</div><div class="line"></div><div class="line">  context.system.scheduler  <span class="comment">//定时器，定时触发抽奖逻辑</span></div><div class="line">    .schedule(</div><div class="line">      <span class="number">0.</span>milliseconds,</div><div class="line">      <span class="number">100.</span>milliseconds,</div><div class="line">      <span class="keyword">new</span> <span class="type">Runnable</span> &#123;</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span> </span>= &#123;</div><div class="line">          self ! <span class="string">"doLottery"</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveCommand</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> lc: <span class="type">LotteryCmd</span> =&gt;</div><div class="line">      lotteryQueue = lotteryQueue :+ (lc, sender())  <span class="comment">//参与信息加入抽奖队列</span></div><div class="line">      println(<span class="string">s"the lotteryQueue size is <span class="subst">$&#123;lotteryQueue.size&#125;</span>"</span>)</div><div class="line">      <span class="keyword">if</span> (lotteryQueue.size &gt; <span class="number">5</span>)  <span class="comment">//当参与人数有5个时触发抽奖</span></div><div class="line">        joinN(lotteryQueue)</div><div class="line">    <span class="keyword">case</span> <span class="string">"doLottery"</span> =&gt;</div><div class="line">      <span class="keyword">if</span> (lotteryQueue.size &gt; <span class="number">0</span>)</div><div class="line">        joinN(lotteryQueue)</div><div class="line">    <span class="keyword">case</span> <span class="string">"saveSnapshot"</span> =&gt;  <span class="comment">// 接收存储快照命令执行存储快照操作</span></div><div class="line">      saveSnapshot(state)</div><div class="line">    <span class="keyword">case</span> <span class="type">SaveSnapshotSuccess</span>(metadata) =&gt;  ???  <span class="comment">//你可以在快照存储成功后做一些操作，比如删除之前的快照等</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">joinN</span></span>(lotteryQueue: <span class="type">ArrayBuffer</span>[(<span class="type">LotteryCmd</span>, <span class="type">ActorRef</span>)]) = &#123;  <span class="comment">//批量处理抽奖结果</span></div><div class="line">    <span class="keyword">val</span> rs = doLotteryN(lotteryQueue)</div><div class="line">    <span class="keyword">val</span> success = rs.collect &#123;  <span class="comment">//得到其中中奖的相应信息</span></div><div class="line">      <span class="keyword">case</span> (event: <span class="type">LuckyEvent</span>, ref: <span class="type">ActorRef</span>) =&gt;</div><div class="line">        event -&gt; ref</div><div class="line">    &#125;.toMap</div><div class="line">    <span class="keyword">val</span> failure = rs.collect &#123;  <span class="comment">//得到其中未中奖的相应信息</span></div><div class="line">      <span class="keyword">case</span> (event: <span class="type">FailureEvent</span>, ref: <span class="type">ActorRef</span>) =&gt; event -&gt; ref</div><div class="line">    &#125;</div><div class="line">    persistAll(success.keys.toIndexedSeq) &#123;  <span class="comment">//批量持久化中奖用户事件</span></div><div class="line">      <span class="keyword">case</span> event =&gt;  println(event)</div><div class="line">        updateState(event)</div><div class="line">        increaseEvtCountAndSnapshot()</div><div class="line">        success(event) ! event</div><div class="line">    &#125;</div><div class="line">    failure.foreach &#123;</div><div class="line">      <span class="keyword">case</span> (event, ref) =&gt; ref ! event</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.lotteryQueue.clear()  <span class="comment">//清空参与队列</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">increaseEvtCountAndSnapshot</span></span>() = &#123;</div><div class="line">    <span class="keyword">val</span> snapShotInterval = <span class="number">5</span></div><div class="line">    <span class="keyword">if</span> (lastSequenceNr % snapShotInterval == <span class="number">0</span> &amp;&amp; lastSequenceNr != <span class="number">0</span>) &#123;  <span class="comment">//当有持久化5个事件后我们便存储一次当前Actor状态的快照</span></div><div class="line">      self ! <span class="string">"saveSnapshot"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doLotteryN</span></span>(lotteryQueue: <span class="type">ArrayBuffer</span>[(<span class="type">LotteryCmd</span>, <span class="type">ActorRef</span>)]) = &#123;  <span class="comment">//抽奖逻辑具体实现</span></div><div class="line">    <span class="keyword">var</span> remainAmount = state.remainAmount</div><div class="line">    lotteryQueue.map(lq =&gt;</div><div class="line">      <span class="keyword">if</span> (remainAmount &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">val</span> luckyMoney = scala.util.<span class="type">Random</span>.nextInt(remainAmount) + <span class="number">1</span></div><div class="line">        remainAmount = remainAmount - luckyMoney</div><div class="line">        (<span class="type">LuckyEvent</span>(lq._1.userId, luckyMoney),lq._2)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        (<span class="type">FailureEvent</span>(lq._1.userId, <span class="string">"下次早点来，红包已被抽完咯！"</span>),lq._2)</div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是改造后的参与Actor，实现了批量持久的功能，当然这里为了给发送者返回消息，处理逻辑稍微复杂了一点，不过真实场景可能会更复杂，相关源码也在刚才的项目上。</p>
<h4 id="3-Persistence-Query"><a href="#3-Persistence-Query" class="headerlink" title="3.Persistence Query"></a>3.Persistence Query</h4><p>另外Akka Persistence还提供了Query接口，用于需要查询持久化事件的需求，这部分内容可能要根据实际业务场景考虑是否需要应用，我就不展开讲了，另外我也写了一个小demo在项目中，想要尝试的同学也可以试试。</p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/Akka/">Akka</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/07/play-1/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Play! Framework 系列（一）：初探 play 框架</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2017/07/scala-types-of-types-part-6/">
        <span class="next-text nav-default"><译> Scala 类型的类型（六）</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <!--<div style="text-align:center;margin-top: 50px;">
      <a class="btn" href="https://gitter.im/scala_cool/Lobby?source=orgpage" target="_blank">评论这篇文章</a>
    </div>-->
    <div id="gitalk-container"></div>
    <script>
      var gitalk = new Gitalk({
        clientID: '23770b27c2837a5e79a1',
        clientSecret: 'd41712ccd45d7142b31d3b9f355e77f107b29ef2',
        repo: 'scalacool.github.io',
        owner: 'ScalaCool',
        admin: ['yison-dripower'],
        id: '123',
        distractionFreeMode: true
      });
      gitalk.render('gitalk-container');
    </script>
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
    2017
    <span class="footer-author">ScalaCool.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/author.js?v=1.1"></script>

  </body>
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
</html>

<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />


<meta name="description" content="这是水滴产品团队面向 Scala 的中文技术博客，原创 Scala 文章、教程。"/>


<meta name="keywords" content="scala,scala 教程,scala 文章,scala 中文,scala 社区" />

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>



  <link rel="alternate" href="/default" title="ScalaCool">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://scala.cool/2017/08/learning-akka-9/"/>


<meta name="description" content="Akka作为一个天生用于构建分布式应用的工具，当然提供了用于分布式组件即Akka Remote，那么我们就来看看如何用Akka Remote以及Akka Serialization来构建分布式应用。">
<meta name="keywords" content="Akka,~Akka 系列,^Godpan">
<meta property="og:type" content="article">
<meta property="og:title" content="Akka 系列（九）：Akka 分布式之 Akka Remote">
<meta property="og:url" content="http://scala.cool/2017/08/learning-akka-9/index.html">
<meta property="og:site_name" content="ScalaCool">
<meta property="og:description" content="Akka作为一个天生用于构建分布式应用的工具，当然提供了用于分布式组件即Akka Remote，那么我们就来看看如何用Akka Remote以及Akka Serialization来构建分布式应用。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://scala.cool/images/2017/08/jms-point-to-point.png">
<meta property="og:image" content="http://scala.cool/images/2017/08/jms-topic.png">
<meta property="og:image" content="http://scala.cool/images/2017/08/java-rmi-result.png">
<meta property="og:image" content="http://scala.cool/images/2017/08/send-no-return.png">
<meta property="og:image" content="http://scala.cool/images/2017/08/send-has-return.png">
<meta property="og:image" content="http://scala.cool/images/2017/08/send-serialization.png">
<meta property="og:updated_time" content="2018-01-12T05:12:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Akka 系列（九）：Akka 分布式之 Akka Remote">
<meta name="twitter:description" content="Akka作为一个天生用于构建分布式应用的工具，当然提供了用于分布式组件即Akka Remote，那么我们就来看看如何用Akka Remote以及Akka Serialization来构建分布式应用。">
<meta name="twitter:image" content="http://scala.cool/images/2017/08/jms-point-to-point.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dfcb338d3c2ed49b6a5e26760868e19f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> Akka 系列（九）：Akka 分布式之 Akka Remote - ScalaCool </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead" >
<div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">ScalaCool</a>
    </h1>
    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="http://news.scala.cool">
                            
                            
                                动态
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="https://scala.cool/2017/03/hello-scala/">
                            
                            
                                关于
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="https://medium.com/drip-engineering">
                            
                            
                                EN
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Akka 系列（九）：Akka 分布式之 Akka Remote
        
      </h1>

      <time class="post-time">
          8月28日
      </time>
      
        <span class="author-split">|</span>
        <span class="author-info">
          by <span class="_author-text-holder" data-author="Godpan"></span>
        </span>
      
      
        <div class="avatar-holder">
          <span class="_author-avatar-holder" data-author="Godpan"></span>
        </div>
      
    </header>



    
            <div class="post-content">
            <p>Akka作为一个天生用于构建分布式应用的工具，当然提供了用于分布式组件即Akka Remote，那么我们就来看看如何用Akka Remote以及Akka Serialization来构建分布式应用。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>很多同学在程序的开发中都会遇到一个问题，当业务需求变得越来越复杂，单机服务器已经不足以承载相应的请求的时候，我们都会考虑将服务部署到不同的服务器上，但服务器之间可能需要相互调用，那么系统必须拥有相互通信的接口，用于相应的数据交互，这时候一个好的远程调用方案是一个绝对的利器，主流的远程通信有以下几种选择：</p>
<ul>
<li>RPC（Remote Procedure Call Protocol）</li>
<li>Web Service</li>
<li>JMS（Java Messaging Service）</li>
</ul>
<p>这几种方式都是被采用比较广泛的通信方案，有兴趣的同学可以自己去了解一下，这里我会讲一下Java中的RPC即RMI （Remote Method Invocation）和JMS。</p>
<h3 id="JAVA远程调用"><a href="#JAVA远程调用" class="headerlink" title="JAVA远程调用"></a>JAVA远程调用</h3><p>RMI和JMS相信很多写过Java程序的同学都知道，是Java程序用来远程通信的主要方式，那么RMI和JMS又有什么区别呢？</p>
<h4 id="1-RMI"><a href="#1-RMI" class="headerlink" title="1.RMI"></a>1.RMI</h4><h5 id="i-特征："><a href="#i-特征：" class="headerlink" title="i.特征："></a>i.特征：</h5><ul>
<li>同步通信：在使用RMI调用远程方法时，线程会持续等待直到结果返回，所以它是一个同步阻塞操作；</li>
<li>强耦合：请求的系统中需要使用的RMI服务进行接口声明，返回的数据类型有一定的约束；</li>
</ul>
<h5 id="ii-优点："><a href="#ii-优点：" class="headerlink" title="ii.优点："></a>ii.优点：</h5><ul>
<li>实现相对简单，方法调用形式通俗易理解，接口声明服务功能清晰。</li>
</ul>
<h5 id="iii-缺点："><a href="#iii-缺点：" class="headerlink" title="iii.缺点："></a>iii.缺点：</h5><ul>
<li>只局限支持JVM平台；</li>
<li>对无法兼容Java语言的其他语言也不适用；</li>
</ul>
<h4 id="2-JMS"><a href="#2-JMS" class="headerlink" title="2.JMS"></a>2.JMS</h4><h5 id="i-特征：-1"><a href="#i-特征：-1" class="headerlink" title="i.特征："></a>i.特征：</h5><ul>
<li>异步通信：JMS发送消息进行通信，在通信过程中，线程不会被阻塞，不必等待请求回应，所以是一个异步操作；</li>
<li>松耦合：不需要接口声明，返回的数据类型可以是各种各样，比如JSON，XML等；</li>
</ul>
<h5 id="ii-通信方式："><a href="#ii-通信方式：" class="headerlink" title="ii.通信方式："></a>ii.通信方式：</h5><p>（1）点对点消息传送模型</p>
<p>顾名思义，点对点可以理解为两个服务器的定点通信，发送者和接收者都能明确知道对方是谁，大致模型如下：<br><img src="/images/2017/08/jms-point-to-point.png" alt="jms-point-to-point"></p>
<p>（2）发布/订阅消息传递模型</p>
<p>点对点模型有些场景并不是很适用，比如有一台主服务器，它产生一条消息需要让所有的从服务器都能收到，若采用点对点模型的话，那主服务器需要循环发送消息，后续若有新的从服务器增加，还要改主服务器的配置，这样就会导致不必要的麻烦，那么发布/订阅模型是怎么样的呢？其实这种模式跟设计模式中的观察者模式很相似，相信很多同学都很熟悉，它最大的特点就是较松耦合，易扩展等特点，所以发布/订阅模型的大致结构如下：</p>
<p><img src="/images/2017/08/jms-topic.png" alt="jms-point-to-point"></p>
<h5 id="iii-优点："><a href="#iii-优点：" class="headerlink" title="iii.优点："></a>iii.优点：</h5><ul>
<li>由于使用异步通信，不需要线程暂停等待，性能相对较高。</li>
</ul>
<h5 id="iiii-缺点："><a href="#iiii-缺点：" class="headerlink" title="iiii.缺点："></a>iiii.缺点：</h5><ul>
<li>技术实现相对复杂，并需要维护相关的消息队列；</li>
</ul>
<p>更通俗的说：</p>
<p><strong>RMI可以看成是用打电话的方式进行信息交流，而JMS更像是发短信。</strong></p>
<p>总的来说两种方式没有孰优孰劣，我们也不用比较到底哪种方式比较好，存在即合理，更重要的是哪种选择可能更适合你的系统。</p>
<h3 id="RMI-Example"><a href="#RMI-Example" class="headerlink" title="RMI Example"></a>RMI Example</h3><p>这里我写一个RMI的例子，一方面来看一下它的使用方式，另一方面用于和后续的Akka Remote做一些比较：</p>
<p>首先我们来编写相应的传输对象和通信接口：</p>
<p>1.JoinRmiEvt：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinRmiEvt</span> <span class="keyword">implements</span> <span class="title">Remote</span> , <span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JoinRmiEvt</span><span class="params">(Long id, String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.RemoteRmi:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteRmi</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNoReturn</span><span class="params">(String message)</span> <span class="keyword">throws</span> RemoteException, InterruptedException</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendHasReturn</span><span class="params">(JoinRmiEvt joinRmiEvt)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在服务端对该接口进行实现：</p>
<p>3.RemoteRmiImpl:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteRmiImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">RemoteRmi</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">RemoteRmiImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNoReturn</span><span class="params">(String message)</span> <span class="keyword">throws</span> RemoteException, InterruptedException </span>&#123;</div><div class="line">        Thread.sleep(<span class="number">2000</span>);</div><div class="line">        <span class="comment">//throw new RemoteException(); </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendHasReturn</span><span class="params">(JoinRmiEvt joinRmiEvt)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">      <span class="keyword">if</span> (joinRmiEvt.getId() &gt;= <span class="number">0</span>)</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">"the"</span>).append(joinRmiEvt.getName()).append(<span class="string">"has join"</span>).toString();</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着我们在Server端绑定相应端口并发布服务，然后启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteRMIServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException, MalformedURLException, InterruptedException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"the RemoteRMIServer is Starting ..."</span>);</div><div class="line">        RemoteRmiImpl remoteRmi = <span class="keyword">new</span> RemoteRmiImpl();</div><div class="line">        System.out.println(<span class="string">"Binding server implementation to registry"</span>);</div><div class="line">        LocateRegistry.createRegistry(<span class="number">2553</span>);</div><div class="line">        Naming.bind(<span class="string">"rmi://127.0.0.1:2553/remote_rmi"</span>,remoteRmi);</div><div class="line">        System.out.println(<span class="string">"the RemoteRMIServer is Started"</span>);</div><div class="line">        Thread.sleep(<span class="number">10000000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们在Client端调用Server端的服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteRmiClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException, InterruptedException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"the client has started"</span>);</div><div class="line">        String url = <span class="string">"rmi://127.0.0.1:2553/remote_rmi"</span>;</div><div class="line">        RemoteRmi remoteRmi = (RemoteRmi) Naming.lookup(url);</div><div class="line">        System.out.println(<span class="string">"the client has running"</span>);</div><div class="line">        remoteRmi.sendNoReturn(<span class="string">"send no return"</span>);</div><div class="line">        System.out.println(remoteRmi.sendHasReturn(<span class="keyword">new</span> JoinRmiEvt(<span class="number">1L</span>,<span class="string">"godpan"</span>)));</div><div class="line">        System.out.println(<span class="string">"the client has end"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/images/2017/08/java-rmi-result.png" alt="java-rmi-result"></p>
<p>从运行结果和代码上分析可得：</p>
<ul>
<li>Java Rmi调用是一个阻塞的过程，这会导致一个问题，假如服务端的服务奔溃了，会导致客户端没有反应；</li>
<li>Java Rmi使用的是Java默认的序列化方式,性能并不是很好，而且并不提供支持使用其他序列化的接口，在一些性能要求高的系统会有一定的瓶颈；</li>
<li>在Rmi中使用的相应的接口和对象必须实现相应的接口，必须制定抛出相应的Exception，导致代码看起来异常的繁琐；</li>
</ul>
<h3 id="Akka-Remote"><a href="#Akka-Remote" class="headerlink" title="Akka Remote"></a>Akka Remote</h3><p>上面讲到JAVA中远程通信的方式，但我们之前说过Akka也是基于JVM平台的，那么它的通信方式又有什么不同呢？</p>
<p>在我看来，Akka的远程通信方式更像是RMI和JMS的结合，但更偏向于JMS的方式，为什么这么说呢，我们先来看一个示例:</p>
<p>我们先来创建一个远程的Actor：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</div><div class="line">    <span class="keyword">case</span> msg: <span class="type">String</span> =&gt;</div><div class="line">      println(<span class="string">s"RemoteActor received message '<span class="subst">$msg</span>'"</span>)</div><div class="line">      sender ! <span class="string">"Hello from the RemoteActor"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们在远程服务器上启动这个Actor：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"RemoteDemoSystem"</span>)</div><div class="line"><span class="keyword">val</span> remoteActor = system.actorOf(<span class="type">Props</span>[<span class="type">RemoteActor</span>], name = <span class="string">"RemoteActor"</span>)</div></pre></td></tr></table></figure>
<p>那么现在我们假如有一个系统需要向这个Actor发送消息应该怎么做呢？</p>
<p>首先我们需要类似RMI发布自己的服务一样，我们需要为其他系统调用远程Actor提供消息通信的接口，在Akka中，设置非常简单，不需要代码侵入，只需简单的在配置文件里配置即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">akka &#123;</div><div class="line">  actor &#123;</div><div class="line">    provider = &quot;akka.remote.RemoteActorRefProvider&quot;</div><div class="line">  &#125;</div><div class="line">  remote &#123;</div><div class="line">    enabled-transports = [&quot;akka.remote.netty.tcp&quot;]</div><div class="line">    netty.tcp &#123;</div><div class="line">      hostname = $localIp  //比如127.0.0.1</div><div class="line">      port = $port //比如2552</div><div class="line">    &#125;</div><div class="line">    log-sent-messages = on</div><div class="line">    log-received-messages = on</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只需配置相应的驱动，传输方式，ip，端口等属性就可简单完成Akka Remote的配置。</p>
<p>当然本地服务器也需要配置这些信息，因为Akka之间是需要相互通信的，当然配置除了hostname有一定的区别外，其他配置信息可一致，本例子是在同一台机器上，所以这里hostname是相同的。</p>
<p>这时候我们就可以在本地的服务器向这个Actor发送消息了，首先我们可以创建一个本地的Actor：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Init</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SendNoReturn</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> path = <span class="type">ConfigFactory</span>.defaultApplication().getString(<span class="string">"remote.actor.name.test"</span>)</div><div class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">4.</span>seconds)</div><div class="line">  <span class="keyword">val</span> remoteActor = context.actorSelection(path)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Init</span> =&gt; <span class="string">"init local actor"</span></div><div class="line">    <span class="keyword">case</span> <span class="type">SendNoReturn</span> =&gt; remoteActor ! <span class="string">"hello remote actor"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>remote.actor.name.test</code>的值为：“akka.tcp://RemoteDemoSystem@127.0.0.1:4444/user/RemoteActor”，另外我们可以看到我们使用了<code>context.actorSelection(path)</code>来获取的是一个ActorSelection对象，若是需要获得ActorRef，我们可以调用它的resolveOne(),它返回的是是一个Future[ActorRef],这里是不是很熟悉，因为它跟本地获取Actor方式是一样的，因为Akka中Actor是位置透明的，获取本地Actor和远程Actor是一样的。</p>
<p>最后我们首先启动远程Actor的系统：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RemoteDemo</span> <span class="keyword">extends</span> <span class="title">App</span>  </span>&#123;</div><div class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"RemoteDemoSystem"</span>)</div><div class="line">  <span class="keyword">val</span> remoteActor = system.actorOf(<span class="type">Props</span>[<span class="type">RemoteActor</span>], name = <span class="string">"RemoteActor"</span>)</div><div class="line">  remoteActor ! <span class="string">"The RemoteActor is alive"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们在本地系统中启动这个LocalActor，并向它发送消息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">LocalDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"LocalDemoSystem"</span>)</div><div class="line">  <span class="keyword">val</span> localActor = system.actorOf(<span class="type">Props</span>[<span class="type">LocalActor</span>], name = <span class="string">"LocalActor"</span>)</div><div class="line"></div><div class="line">  localActor ! <span class="type">Init</span></div><div class="line">  localActor ! <span class="type">SendNoReturn</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到RemoteActor收到了一条消息：</p>
<p><img src="/images/2017/08/send-no-return.png" alt="send-no-return"></p>
<p>从以上的步骤和结果看出可以看出，Akka的远程通信跟JMS的点对点模式似乎更相似一点，但是它有不需要我们维护消息队列，而是使用Actor自身的邮箱，另外我们利用context.actorSelection获取的ActorRef，可以看成远程Actor的副本，这个又和RMI相关概念类似，所以说Akka远程通信的形式上像是RMI和JMS的结合,当然底层还是通过TCP、UDP等相关网络协议进行数据传输的，从配置文件的相应内容便可以看出。</p>
<p>上述例子演示的是sendNoReturn的模式，那么假如我们需要远程Actor给我们一个回复应该怎么做呢？</p>
<p>首先我们创建一个消息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SendHasReturn</span></span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">SendHasReturn</span> =&gt;</div><div class="line">      <span class="keyword">for</span> &#123;</div><div class="line">        r &lt;- remoteActor.ask(<span class="string">"hello remote actor"</span>)</div><div class="line">      &#125; <span class="keyword">yield</span> r</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>我们重新运行LocalActor并像RemoteActor发送一条消息：</p>
<p><img src="/images/2017/08/send-has-return.png" alt="send-has-return"></p>
<p>可以看到LocalActor在发送消息后并收到了RemoteActor返回来的消息，另外我们这里设置了超时时间，若在规定的时间内没有得到反馈，程序就会报错。</p>
<h3 id="Akka-Serialization"><a href="#Akka-Serialization" class="headerlink" title="Akka Serialization"></a>Akka Serialization</h3><p>其实这一部分本可以单独拿出来写，但是相信序列化这块大家都应该有所了解了，所以就不准备讲太多序列化的知识了，怕班门弄斧，主要讲讲Akka中的序列化。</p>
<p>继续上面的例子，假如我们这时向RemoteActor发送一个自定义的对象，比如一个case class对象，但是我们这是是在网络中传输这个消息，那么怎么保证这个对象类型和值呢，在同一个JVM系统中我们不需要担心这个，因为对象就在堆中，我们只要传递相应的地址即可就行，但是在不同的环境中，我们并不能这么做，我们在网络中只能传输字节数据，所以我们必须将对象做特殊的处理，在传输的时候转化成特定的由一连串字节组成的数据，而且我们又可以根据这些数据恢复成一个相应的对象，这便是序列化。</p>
<p>我们先定义一个参与的case class, 并修改一下上面发送消息的语句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">case object SendSerialization</div><div class="line">case class JoinEvt(</div><div class="line">    id: Long,</div><div class="line">    name: String</div><div class="line">)</div><div class="line">def receive: Receive = &#123;</div><div class="line">    case SendSerialization =&gt;</div><div class="line">      for &#123;</div><div class="line">        r &lt;- remoteActor.ask(JoinEvt(1L,&quot;godpan&quot;))</div><div class="line">      &#125; yield println(r)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这时我们重新启动RemoteActor和LocalActor所在的系统，发送这条消息：</p>
<p><img src="/images/2017/08/send-serialization.png" alt="send-serialization"></p>
<p>有同学可能会觉得奇怪，我们明明没有对JoinEvt进行过任何序列化的标识和处理，为什么程序还能运行成功呢？</p>
<p>其实不然，只不过是有人替我们默认做了，不用说，肯定是贴心的Akka，它为我们提供了一个默认的序列化策略，那就是我们熟悉又纠结的java.io.Serializable，沉浸在它的易使用性上，又对它的性能深恶痛绝，尤其是当有大量对象需要传输的分布式系统，如果是小系统，当我没说，毕竟存在即合理。</p>
<p>又有同学说，既然Akka是一个天生分布式组件，为什么还用低效的java.io.Serializable，你问我我也不知道，可能当时的作者偷了偷懒，当然Akka现在可能觉醒了，首先它支持第三方的序列化工具，当然如果你有特殊需求，你也可以自己实现一个，而且在最新的文档中说明，在Akka 2.5x之后Akka内核消息全面废弃java.io.Serializable，用户自定义的消息暂时还是支持使用java.io.Serializable的，但是不推荐用，因为它是低效的，容易被攻击，所以在这里我也推荐大家再Akka中尽量不要在使用了java.io.Serializable。</p>
<p>那么在Akka中我们如何使用第三方的序列化工具呢？</p>
<p>这里我推荐一个在Java社区已经久负盛名的序列化工具：kryo，有兴趣的同学可以去了解一下：<a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="external">kryo</a>,而且它也提供Akka使用的相关包，这里我们就使用它作为示例：</p>
<p>这里我贴上整个项目的build.sbt, kryo的相关依赖也在里面：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> sbt._</div><div class="line"><span class="keyword">import</span> sbt.<span class="type">Keys</span>._</div><div class="line"></div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> <span class="type">AllLibraryDependencies</span> =</div><div class="line">  <span class="type">Seq</span>(</div><div class="line">    <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-actor"</span> % <span class="string">"2.5.3"</span>,</div><div class="line">    <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-remote"</span> % <span class="string">"2.5.3"</span>,</div><div class="line">    <span class="string">"com.twitter"</span> %% <span class="string">"chill-akka"</span> % <span class="string">"0.8.4"</span></div><div class="line">  )</div><div class="line"></div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> commonSettings = <span class="type">Seq</span>(</div><div class="line">  name := <span class="string">"AkkaRemoting"</span>,</div><div class="line">  version := <span class="string">"1.0"</span>,</div><div class="line">  scalaVersion := <span class="string">"2.11.11"</span>,</div><div class="line">  libraryDependencies := <span class="type">AllLibraryDependencies</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> remote = (project in file(<span class="string">"remote"</span>))</div><div class="line">  .settings(commonSettings: _*)</div><div class="line">  .settings(</div><div class="line">    <span class="comment">// other settings</span></div><div class="line">  )</div><div class="line"></div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> local = (project in file(<span class="string">"local"</span>))</div><div class="line">  .settings(commonSettings: _*)</div><div class="line">  .settings(</div><div class="line">    <span class="comment">// other settings</span></div><div class="line">  )</div></pre></td></tr></table></figure>
<p>然后我们只需将application.conf中的actor配置替换成以下的内容：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">actor &#123;</div><div class="line">    provider = <span class="string">"akka.remote.RemoteActorRefProvider"</span></div><div class="line">    serializers &#123;</div><div class="line">      kryo = <span class="string">"com.twitter.chill.akka.AkkaSerializer"</span></div><div class="line">    &#125;</div><div class="line">    serialization-bindings &#123;</div><div class="line">      <span class="string">"java.io.Serializable"</span> = none</div><div class="line">      <span class="string">"scala.Product"</span> = kryo</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其实其中的”java.io.Serializable” = none可以省略，因为若是有其他序列化的策略则会替换掉默认的java.io.Serializable的策略，这里只是为了更加仔细的说明。</p>
<p>至此我们就可以使用kryo了，整个过程是不是很easy，迫不及待开始写demo了，那就快快开始吧。</p>
<p>从运行结果和代码上分析可得：</p>
<ul>
<li>Akka Remote使用内置的序列化工具，并支持配置指定的序列化方式，可以按需配置；</li>
<li>Akka Remote使用的过程是一个异步非阻塞的过程，客户端能尽量减少对服务端的依赖；</li>
<li>Akka Remote的代码实现相对Java Rmi实现来说简单的多，非常简洁；</li>
</ul>
<p>1.Akka Remote </p>
<p>整个例子的相关的源码已经上传到akka-demo中：<a href="https://github.com/godpan/akka-demo/tree/master/Example_06" target="_blank" rel="external">源码链接</a></p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/Akka/">Akka</a>
          
            <a href="/tags/Akka-系列/">~Akka 系列</a>
          
            <a href="/tags/Godpan/">^Godpan</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/09/scala-weekly-19/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Scala 技术周刊 | 第 19 期</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2017/08/subtyping-vs-typeclasses/">
        <span class="next-text nav-default">Subtyping vs Typeclasses（一）</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <!--<div style="text-align:center;margin-top: 50px;">
      <a class="btn" href="https://gitter.im/scala_cool/Lobby?source=orgpage" target="_blank">评论这篇文章</a>
    </div>-->
    <div id="gitalk-container"></div>
    <script>
      var Base64={_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:function(e){var t="";var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,"n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},_utf8_decode:function(e){var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}} 
      var id = Base64.encode(document.getElementsByClassName('post-title')[0].innerHTML.trim())
      id = id.length > 50 && 1503885600000 > 1517414400123 ? id.slice(-50, id.length) : id;
      var gitalk = new Gitalk({
        clientID: '23770b27c2837a5e79a1',
        clientSecret: 'd41712ccd45d7142b31d3b9f355e77f107b29ef2',
        repo: 'scalacool.github.io',
        owner: 'ScalaCool',
        admin: ['yisonshan'],
        id: id,
        distractionFreeMode: true
      });
      gitalk.render('gitalk-container');
    </script>
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2019
    <span class="footer-author">ScalaCool.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/author.js?v=1.1"></script>

  </body>
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
</html>

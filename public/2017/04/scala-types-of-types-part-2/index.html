<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Scala 的 object 是通过 class 实现的（显然后者是 JVM 的基础构件）。然而你也会发现我们并不能像一个简单的类一样，轻松地获得一个 object 的类型……"/>




  <meta name="keywords" content="类型相关,翻译," />





  <link rel="alternate" href="/default" title="Scala Cool">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://scala.cool/2017/04/scala-types-of-types-part-2/"/>


<meta name="description" content="Scala 的 object 是通过 class 实现的（显然后者是 JVM 的基础构件）。然而你也会发现我们并不能像一个简单的类一样，轻松地获得一个 object 的类型……">
<meta property="og:type" content="article">
<meta property="og:title" content="<译> Scala 类型的类型（二）">
<meta property="og:url" content="http://scala.cool/2017/04/scala-types-of-types-part-2/index.html">
<meta property="og:site_name" content="Scala Cool">
<meta property="og:description" content="Scala 的 object 是通过 class 实现的（显然后者是 JVM 的基础构件）。然而你也会发现我们并不能像一个简单的类一样，轻松地获得一个 object 的类型……">
<meta property="og:updated_time" content="2017-04-08T08:16:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="<译> Scala 类型的类型（二）">
<meta name="twitter:description" content="Scala 的 object 是通过 class 实现的（显然后者是 JVM 的基础构件）。然而你也会发现我们并不能像一个简单的类一样，轻松地获得一个 object 的类型……">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dfcb338d3c2ed49b6a5e26760868e19f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> <译> Scala 类型的类型（二） - Scala Cool </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Scala Cool</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="http://news.scala.cool">
                            
                            
                                News
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <译> Scala 类型的类型（二）
        
      </h1>

      <time class="post-time">
          4月2日
      </time>
      
        <span class="author-split">|</span>
        <span class="author-info">
          by <span class="_author-text-holder" data-author="Yison"></span>
        </span>
      
      
        <span class="_author-avatar-holder" data-author="Yison"></span>
      
    </header>



    
            <div class="post-content">
            <h2 id="上一篇"><a href="#上一篇" class="headerlink" title="上一篇"></a>上一篇</h2><p><a href="http://yison.me/page/scala-types-of-types/part-1" target="_blank" rel="external">Scala 类型的类型（一）</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="">6. 一个 <code>object</code> 的类型</a></li>
<li><a href="">7. Scala 中的型变</a></li>
<li><a href="">8. Refined Types (refinements)</a></li>
<li><a href="">9. Package Object</a></li>
<li><a href="">10. Type Alias</a></li>
</ul>
<h2 id="6-一个-object-的类型"><a href="#6-一个-object-的类型" class="headerlink" title="6. 一个 object 的类型"></a>6. 一个 <code>object</code> 的类型</h2><p>Scala 的 <code>object</code> 是通过 <code>class</code> 实现的（显然后者是 JVM 的基础构件）。然而你也会发现我们并不能像一个简单的类一样，轻松地获得一个 <code>object</code> 的类型……</p>
<p>我常常疑惑该如何传一个 <code>object</code> 给一个方法，对此我自己也非常惊讶。我的意思是指 <code>obj: ExampleObj</code> 是无效的，因为这种情况 <code>ExampleObj</code> 已经指向了实例，所以它有个 <code>type</code> 的成员，我们可以靠它解决问题。</p>
<p>下面的代码解释了大概的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">ExampleObj</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeAnObject</span></span>(obj: <span class="type">ExampleObj</span>.<span class="keyword">type</span>) = &#123;&#125;</div><div class="line"></div><div class="line">takeAnObject(<span class="type">ExampleObj</span>)</div></pre></td></tr></table></figure></p>
<h2 id="7-Scala-中的型变"><a href="#7-Scala-中的型变" class="headerlink" title="7. Scala 中的型变"></a>7. Scala 中的型变</h2><p>型变，通常可以解释成类型之间依靠彼此的「兼容性」，形成一种继承的关系。最常见的例子就是当你要处理「容器」或「函数」的时候，有时就必须要处理型变（极其的常见！）。</p>
<p>Scala 跟 Java 一个重大的差异，就是它的「容器类型」默认是不可变的！也就是说，如果你有一个定义为 <code>Box[A]</code> 的容器，然后在使用的时候将其中的类型参数 <code>A</code> 替换成 <code>Fruit</code>，之后你就不能插入类型 <code>Apple</code>（这也是一种 <code>Fruit</code> 类型）。</p>
<p>Scala 中的型变通过在「类型参数」前使用 <code>+</code> 和 <code>-</code> 符号来定义。</p>
<p>参见：<a href="http://www.slideshare.net/dgalichet/demystifying-scala-type-system" target="_blank" rel="external">http://www.slideshare.net/dgalichet/demystifying-scala-type-system</a>。</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>描述</th>
<th>Scala 语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>非型变的</td>
<td>C[T’] 与 C[T] 是不相干的</td>
<td>C[T]</td>
</tr>
<tr>
<td>协变的</td>
<td>C[T’] 是 C[T] 的子类</td>
<td>C[+T]</td>
</tr>
<tr>
<td>逆变的</td>
<td>C[T] 是 C[T’] 的子类</td>
<td>C[-T]</td>
</tr>
</tbody>
</table>
<p>以上的表格比较抽象地表明了所有我们需要担心的型变情况。也许你还在疑惑什么时候你需要关心这些？事实上，当你每次处理 collection 的时候就遭遇到了，你必须思考「这是一个协变吗？」。</p>
<blockquote>
<p>大部分不可变的 collection 是协变的，而大多数可变的 collection 是逆变的。</p>
</blockquote>
<p>在 Scala 中（至少）有两个不错并很直观的例子。一个是「any collection」，我们将使用 <code>List[+A]</code> 来举例；另一个就是「函数」。</p>
<p>当我们讨论 Scala 中的 <code>List</code> 时，通常指的是 <code>scala.collection.immutable.List[+A]</code> ，它不可变，且是协变的。让我们看看这与「构建一个包含不同类型成员的 list」有什么联系。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">Fruit</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">Fruit</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> l1: <span class="type">List</span>[<span class="type">Apple</span>] = <span class="type">Apple</span>() :: <span class="type">Nil</span></div><div class="line"><span class="keyword">val</span> l2: <span class="type">List</span>[<span class="type">Fruit</span>] = <span class="type">Orange</span>() :: l1</div><div class="line"></div><div class="line"><span class="comment">// and also, it's safe to prepend with "anything",</span></div><div class="line"><span class="comment">// as we're building a new list - not modifying the previous instance</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> l3: <span class="type">List</span>[<span class="type">AnyRef</span>] = <span class="string">""</span> :: l2</div></pre></td></tr></table></figure>
<p>值得一提的是，当存在<strong>不可变的 collection 时，协变是安全的</strong>。如果 collection 可变，则不成立。这里典型的例子是 <code>Array[T]</code>，它是逆变的。下面就来看看「逆变」对我们来说意味着什么，以及它是如何让我们免于错误：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// won't compile</span></div><div class="line"><span class="keyword">val</span> a: <span class="type">Array</span>[<span class="type">Any</span>] = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>因为 <code>Array</code> 的逆变，这样一个赋值操作就不会被编译。假使这个赋值被通过了，我们就陷入麻烦了。我们会写出这样子的代码：<code>a(0) = &quot;&quot; // ArrayStoreException!</code>，这将引发可怕的 <code>ArrayStoreException</code> 失败。</p>
<blockquote>
<p>我们曾说过在 Scala 中「大部分」不可变的 collection 是协变的。如果你想知道一个「相反是逆变」的特例，它是 <code>Set[A]</code> 。</p>
</blockquote>
<h3 id="7-1-特质（trait）-—-如同「带有实现的接口」"><a href="#7-1-特质（trait）-—-如同「带有实现的接口」" class="headerlink" title="7.1 特质（trait） —  如同「带有实现的接口」"></a>7.1 特质（trait） —  如同「带有实现的接口」</h3><p>首先，让我们看看关于「特质」最简单的一个问题：我们如何将多个特质混入到一个类型中，就像如果你来自 Java，会把这叫做实现这些「带有实现的接口」一样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">b</span> </span>= <span class="string">""</span> &#125;</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Cool</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">c</span> </span>= <span class="string">""</span> &#125;</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Awesome</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">a</span> </span>=<span class="string">""</span> &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BA</span> <span class="keyword">extends</span> <span class="title">Base</span> <span class="keyword">with</span> <span class="title">Awesome</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BC</span> <span class="keyword">extends</span> <span class="title">Base</span> <span class="keyword">with</span> <span class="title">Cool</span></span></div><div class="line"></div><div class="line"><span class="comment">// as you might expect, you can upcast these instances into any of the traits they've mixed-in</span></div><div class="line"><span class="keyword">val</span> ba: <span class="type">BA</span> = <span class="keyword">new</span> <span class="type">BA</span></div><div class="line"><span class="keyword">val</span> bc: <span class="type">Base</span> <span class="keyword">with</span> <span class="type">Cool</span> = <span class="keyword">new</span> <span class="type">BC</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> b1: <span class="type">Base</span> = ba</div><div class="line"><span class="keyword">val</span> b2: <span class="type">Base</span> = bc</div><div class="line"></div><div class="line">ba.a</div><div class="line">bc.c</div><div class="line">b1.b</div></pre></td></tr></table></figure>
<p>截止目前的内容，你应该相对比较好理解。现在我们就要讨论「钻石问题」了，熟悉 C++ 的朋友可能一直都比较期待吧。「钻石问题」（菱形继承问题）主要描述的是在「多重继承」的时候，我们「无法明确想要继承什么」的处境。如果你认为特质类似多重继承一样，下图揭示了这个问题。</p>
<h3 id="7-2-类型线性化-VS-钻石问题"><a href="#7-2-类型线性化-VS-钻石问题" class="headerlink" title="7.2 类型线性化 VS 钻石问题"></a>7.2 类型线性化 VS 钻石问题</h3>
            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/类型相关/">类型相关</a>
          
            <a href="/tags/翻译/">翻译</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/04/learning-akka-2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Akka 系列（二）：Akka 中的 Actor 系统</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2017/03/scala-types-of-types-part-1/">
        <span class="next-text nav-default"><译> Scala 类型的类型（一）</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <div style="text-align:center;margin-top: 50px;">
      <a class="btn" href="https://gitter.im/scala_cool/Lobby?source=orgpage" target="_blank">评论这篇文章</a>
    </div>
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
    2017
    <span class="footer-author">ScalaCool.</span>
    <span class="power-by">
        由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/author.js?v=1.1"></script>

  </body>
</html>

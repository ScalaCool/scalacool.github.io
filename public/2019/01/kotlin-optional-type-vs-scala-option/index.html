<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />


<meta name="description" content="这是水滴产品团队面向 Scala 的中文技术博客，原创 Scala 文章、教程。"/>


<meta name="keywords" content="scala,scala 教程,scala 文章,scala 中文,scala 社区" />

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>



  <link rel="alternate" href="/default" title="ScalaCool">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://scala.cool/2019/01/kotlin-optional-type-vs-scala-option/"/>


<meta name="description" content="最近阅读一些关于 Kotlin 类型系统方面的书，发现 Kotlin 的类型系统针对 null 有着独特的设计哲学。">
<meta name="keywords" content="类型相关,Kotlin,^KnewHow">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin Type? vs Scala Option">
<meta property="og:url" content="http://scala.cool/2019/01/kotlin-optional-type-vs-scala-option/index.html">
<meta property="og:site_name" content="ScalaCool">
<meta property="og:description" content="最近阅读一些关于 Kotlin 类型系统方面的书，发现 Kotlin 的类型系统针对 null 有着独特的设计哲学。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-01-04T05:34:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin Type? vs Scala Option">
<meta name="twitter:description" content="最近阅读一些关于 Kotlin 类型系统方面的书，发现 Kotlin 的类型系统针对 null 有着独特的设计哲学。">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dfcb338d3c2ed49b6a5e26760868e19f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> Kotlin Type? vs Scala Option - ScalaCool </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead" ><div class="site-header-inner">
    <h1 class="site-title ">
        <a href="/." class="logo">ScalaCool</a>
    </h1>
    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="http://news.scala.cool">
                            
                            
                                动态
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="https://scala.cool/2017/03/hello-scala/">
                            
                            
                                关于
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="https://medium.com/drip-engineering">
                            
                            
                                EN
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Kotlin Type? vs Scala Option
        
      </h1>

      <time class="post-time">
          1月4日
      </time>
      
        <span class="author-split">|</span>
        <span class="author-info">
          by <span class="_author-text-holder" data-author="KnewHow"></span>
        </span>
      
      
        <div class="avatar-holder">
          <span class="_author-avatar-holder" data-author="KnewHow"></span>
        </div>
      
    </header>



    
            <div class="post-content">
            <p>最近阅读一些关于 Kotlin 类型系统方面的书，发现 Kotlin 的类型系统针对 <code>null</code> 有着独特的设计哲学。在 Java 或者其它编程语言中，经常会出现 <code>NullPointerException</code>，而导致此异常的重要原因是因为你可以写 <code>String s = null</code> 这样的代码。其实可以认为这是 Java 等语言类型系统设计的一个缺陷，它们允许 <code>null</code> 可以作为任何类型的值！</p>
<p>但是在 Kotlin 中，如果你声明 <code>val s: String = null</code>，那么编译器会给你一个 error，因为在 Kotlin 中，你不允许把一个 <code>null</code> 值赋给一个普通的类型。如果你声明一个这样的函数 <code>fun strLen(s: String) = {...}</code>，那么这个函数将不接受值为 <code>null</code> 的参数。</p>
<p>这个设计看起来如此的美好，他可以极大程度的减少 Kotlin 产生 <code>NullPointerException</code>，可是如果有一天，你需要调用一个方法，它的返回值可能为 <code>null</code> 也可能为 <code>String</code> ，那么在 Kotlin 中你可以声明一个可空的字符串类型：<code>String?</code>。<code>val s: String? = null</code> 此时 Kotlin 的编译器会让这行代码通过。当然它也可以接收一个普通的 <code>String</code> 类型的值 <code>val s: String? = &quot;abc&quot;</code>。</p>
<p>可空类型(<code>Type?</code>)的设计，是 Kotlin 另一个设计哲学，它要求工程师在设计的时候就需要确定该变量是否可为空。如果不为空就使用<code>Type</code> 类型声明，否则就使用 <code>Type?</code> 类型声明。这让我想起在 Scala 中存在一个和 <code>Type?</code> 有着异曲同工之妙的一个类型—— <code>Option[T]</code>。</p>
<p><code>Option[T]</code> 有两个子类型：<code>Some[T]</code> 和 <code>None</code>，你可以使用 <code>val s: Option[String] = Some(&quot;123&quot;)</code> 来表示一个字符串存在，当然你可以使用<code>val s: Option[String] = None</code> 来表示这个字符串不存在。</p>
<p>Scala 和 Kotlin 都是基于 JVM 的编程语言，而 <code>Option[T]</code> 和 <code>Type?</code> 的设计就是用来解决 JVM 平台出现的 <code>NullPointerException</code>。但二者的设计理念却截然不同，Scala 的 <code>Option[T]</code> 是在原有类型基础上使用 <code>Option</code> 做一层封装，而 Koltin 的 <code>Type?</code> 是使用语法糖完成的。</p>
<p>那么这两种设计方案到底谁更好一点呢？我们将会使用以下标准来分别测试它们：</p>
<ul>
<li>是否可以完美的规避 <code>NullPointerException</code> —— 二者的设计都是为了解决 <code>NullPointerException</code>，谁可以更好的规避这个问题呢？</li>
<li>代码的可读性 —— 如果在复杂的业务中，谁的代码可读性更好一点呢？</li>
<li>性能</li>
</ul>
<h2 id="规避空指针"><a href="#规避空指针" class="headerlink" title="规避空指针"></a>规避空指针</h2><p>在上文中，我们曾经提过，<code>NullPointerException</code> 产生的原因是你可以把一个 <code>null</code> 的值传递给一个类型的变量，然后调用这个类型的方法。我们可以使用 Java 的代码来表示一下：<code>String s = null; s.length()</code>。</p>
<p>在 <code>Type?</code> 的设计理念中，对于不确定是否为 <code>null</code> 类型可以使用 <code>Type?</code> 类型来声明，如<code>val s: String? = getString...</code>，此时 <code>s</code> 的类型是 <code>String?</code>，你不能直接调用 <code>s.length</code>，你需要进行安全调用<code>s?.length</code>。这个函数的返回类型是一个 <code>Int?</code>，这很正常，对于一个不确定是否为 <code>null</code> 的类型进行安全调用返回当然是一个 <code>Type?</code> 类型。如果 <code>s</code> 不为 <code>null</code> 正常返回 <code>s</code> 的长度，否则返回 <code>null</code>。除此之外， Kotlin 还针对 <code>Type?</code> 提供了 Elvis 操作和 let 函数，具体的用法可以参考 Kotlin 官方手册。</p>
<p>而在 <code>Optional</code> 的设计哲学中，你可以使用 <code>Option[T]</code> 来包裹一个不确定是否为 <code>null</code> 的值。这里我们使用 Scala 的代码来演示：<code>val s: Option[String] = Option(getString...)</code>，此时 <code>s</code> 的类型为 <code>Option[String]</code>，你仍然不能直接调用<code>s.length</code>，你可以使用 <code>map</code> 函数：<code>s.map(s =&gt; s.length)</code>，它的返回值是一个 <code>Option[Int]</code> 类型。和 <code>Type?</code> 很类似，对一个 <code>Option[T]</code> 类型使用 <code>map</code> 函数，结果当然是一个 <code>Option[S]</code> 类型。在 Scala 中，你也可以使用模式匹配来处理 <code>Option</code> 类型。</p>
<p>总结：二者都可以完美的规避 <code>NullPointerException</code>，<code>Type?</code> 使用安全调用来避免直接调用 <code>Type</code> 类型的方法，而 <code>Option</code> 则使用 map 函数或者模式匹配来处理。本质上都是避免直接调用值可能为 <code>null</code> 的类型变量的方法。</p>
<h2 id="代码可读性"><a href="#代码可读性" class="headerlink" title="代码可读性"></a>代码可读性</h2><p>实际的业务是比较复杂的，例如，我们需要计算两个数字字符串的乘积，首先我们需要把他们转换为 <code>Int</code> 类型，如果其中一个字符串是转换失败，则无法计算结果。</p>
<p>在 Kotlin 的 <code>Type?</code> 中，我们需要重新定义 <code>String</code> 类型的 <code>toInt</code> 方法，让它返回一个 <code>Int?</code> 类型，代码如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryString2Int</span><span class="params">(a: <span class="type">String</span>)</span></span> = <span class="keyword">try</span> &#123;</div><div class="line">    a.toInt()</div><div class="line">&#125;<span class="keyword">catch</span> (e:Exception)&#123;</div><div class="line">    <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们需要定义一个方法来计算两个数字字符串的乘积，这里我们使用 <code>Type?</code> 的 let 函数，它接受一个 Lambda 表达式，如果调用者的值不为 <code>null</code>，则调用 Lambda 表达式，否则直接返回 <code>null</code>。<code>strNumberMuti</code> 函数返回的是一个 <code>Double?</code> 类型，如果有任何一个字符串转换数字失败，就返回 <code>null</code>，都转换成功才计算乘积。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strNumberMuti</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>: <span class="built_in">Double</span>? =</div><div class="line">    tryString2Int(s1)?.let&#123; a -&gt;</div><div class="line">        tryString2Int(s2)?.let &#123;</div><div class="line">            t -&gt; a * t * <span class="number">1.0</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的可读取有点差呀，而且在实际的业务开发过程中，可能会有更多的 <code>Type?</code> 类型，那代码岂不是要爆炸了！。幸运的是，Kotlin 允许我们使用 <code>if</code> 来代替 <code>let</code> 函数 做相同的判断，代码如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strNumberMuti2</span><span class="params">(s1: <span class="type">String</span>, s2: <span class="type">String</span>)</span></span>:<span class="built_in">Double</span>? &#123;</div><div class="line">    <span class="keyword">val</span> a = tryString2Int(s1)</div><div class="line">    <span class="keyword">val</span> b = tryString2Int(s2)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">if</span>(a!=<span class="literal">null</span> &amp;&amp; b!= <span class="literal">null</span>) a * b * <span class="number">1.0</span> <span class="keyword">else</span> <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的代码可读性就好多了，但是丢失函数式的编程美感。而且感觉 <code>Type?</code> 是一种语法糖，手动对 <code>Type?</code> 进行非空校验，就可以直接使用 <code>Type</code> 类型了！！</p>
<p>同样的我们使用 Scala 的 <code>Option[T]</code> 来完成上面的需求，为了让 <code>toInt</code> 函数返回 <code>Option[T]</code> 类型，我们定义了一个 <code>Try</code> 函数，这个函数看不懂没关系，你只需知道它接受一个函数，并且返回一个 <code>Option[A]</code> 值即可。代码让如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Try</span></span>[<span class="type">A</span>](a: =&gt; <span class="type">A</span>): <span class="type">Option</span>[<span class="type">A</span>] = &#123;</div><div class="line">    <span class="keyword">try</span> <span class="type">Some</span>(a)</div><div class="line">    <span class="keyword">catch</span> &#123;<span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; <span class="type">None</span>&#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>同样的，我们需要写一个函数，用来把两个字符串数字转换为整数，并且做它们的乘积，这里我们为了使代码更简洁，使用了 Scala 的 for 推导，具体的用法可以参考 Scala 官方的 Document。<code>strNumberNu</code>返回类型是 <code>Option[Double]</code>，如果有任何一个转换失败，返回 <code>None</code>，否则返回 <code>Some[Double]</code>，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strNumberMuti</span></span>(s1: <span class="type">String</span>, s2: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Double</span>] = &#123;</div><div class="line">   <span class="keyword">for</span>&#123;</div><div class="line">     a &lt;- <span class="type">Try</span>&#123; s1.toInt &#125;</div><div class="line">     b &lt;- <span class="type">Try</span>&#123; s2.toInt &#125;</div><div class="line">   &#125; <span class="keyword">yield</span> a * b</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出，使用 Scala 的 <code>Option[T]</code> 更具有函数式的编程美感，而且代码的可读性极强，而且即使有更多的 <code>Option[T]</code>，for 推导都可以轻松应对。</p>
<p>总结：面对比较复杂的业务场景，<code>Type?</code> 和 <code>Option[T]</code> 都可以轻松应对，但是 <code>Type?</code> 的用法就显得有些 low，还是使用 <code>!=null</code> 的套路，这也暴露了它的设计是存在缺陷的。相反的 <code>Option[T]</code> 的设计理念是完备的，而且极具函数式的编程美感。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能是衡量设计好坏的一个重要的方面，下面我们只做一个简单的测试：让两个字符串都是<code>&quot;999&quot;</code>，然后分别执行 Kotlin 的 <code>strNumberMuti</code> 和 Scala 的 <code>strNumberMuti</code> 一千万次，然后我们发现 Kotlin 的 <code>strNumberMuti</code> 执行时间大约在 1.9s，而 Scala 的 <code>strNumberMuti</code> 执行时间约在 5.0s。由此可以看出，Kotlin 的 <code>Type?</code> 比 Scala <code>Option[T]</code> 拥有更好的性能，其实这样很正常，因为 Kotlin 的 <code>Type?</code> 是语法糖，创建一个 <code>Type?</code> 的对象其实和创建一个 <code>Type</code> 的对象其实消耗的性能差不多，但是 <code>Option[T]</code>不仅仅需要创建 <code>T</code> 类型的对象，更需要创建 <code>Option[T]</code> 类型的对象来包裹 <code>T</code> 类型的对象，因此它的开销大一点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就我而言，我更喜欢 Scala 的 <code>Option[T]</code> 的设计，因为它是理论完备的，而且极具函数式的编程美感，即使它的性能要差一点。对于 Kotlin 的 <code>Type?</code> 类型，我觉得它的设计有瑕疵，就拿 <code>let</code> 函数举例，在单个 <code>Type?</code> 很好用，但是当多个 <code>Type?</code> 进行组合的时候，就显得很鸡肋。</p>
<p>萝卜青菜，各有所爱，也许某天 Kotlin 也会让 <code>Type?</code> 具有函数式的编程美感。</p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/类型相关/">类型相关</a>
          
            <a href="/tags/Kotlin/">Kotlin</a>
          
            <a href="/tags/KnewHow/">^KnewHow</a>
          
        </div>

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2017/12/kotlin-4/">
        <span class="next-text nav-default">Dive Into Kotlin（四）：为什么 Kotlin 的根类型是「Any?」</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <!--<div style="text-align:center;margin-top: 50px;">
      <a class="btn" href="https://gitter.im/scala_cool/Lobby?source=orgpage" target="_blank">评论这篇文章</a>
    </div>-->
    <div id="gitalk-container"></div>
    <script>
      var Base64={_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:function(e){var t="";var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,"n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},_utf8_decode:function(e){var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}} 
      var id = Base64.encode(document.getElementsByClassName('post-title')[0].innerHTML.trim())
      id = id.length > 50 && 1546531200000 > 1517414400123 ? id.slice(-50, id.length) : id;
      var gitalk = new Gitalk({
        clientID: '23770b27c2837a5e79a1',
        clientSecret: 'd41712ccd45d7142b31d3b9f355e77f107b29ef2',
        repo: 'scalacool.github.io',
        owner: 'ScalaCool',
        admin: ['yisonshan'],
        id: id,
        distractionFreeMode: true
      });
      gitalk.render('gitalk-container');
    </script>
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2019
    <span class="footer-author">ScalaCool.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/author.js?v=1.1"></script>

  </body>
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
</html>
